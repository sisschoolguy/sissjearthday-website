ts
ï»¿
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Earth Day</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
      /* General Styles */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Montserrat', sans-serif;
        line-height: 1.6;
        color: #333;
      }

      h1, h2 {
        font-weight: 700;
      }

      /* Full-screen Pop-up */
      .popup {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        background-color: #c8e6c9; /* Pastel green */
        display: flex;
        justify-content: center;
        align-items: center;
        transition: all 0.5s ease;
        z-index: 1000;
      }

      .popup-content {
        text-align: center;
      }

      .popup h1 {
        font-size: 4rem;
        margin-bottom: 1rem;
      }

      .popup p {
        font-size: 1.2rem;
        margin-bottom: 2rem;
      }

      .buttons button {
        background: none;
        border: none;
        font-size: 1.2rem;
        margin: 0 1rem;
        cursor: pointer;
        color: #333;
        transition: opacity 0.3s ease;
      }

      .buttons button:hover {
        opacity: 0.7;
      }

      .arrow-down, .arrow-up {
        font-size: 2rem;
        cursor: pointer;
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
      }

      /* Minimized Top Navigation Bar */
      .navbar {
        position: fixed;
        top: -100px; /* Start off-screen */
        left: 0;
        width: 100%;
        background-color: #c8e6c9;
        display: flex;
        align-items: center;
        padding: 1rem 2rem;
        transition: top 0.5s ease;
        z-index: 999;
      }

      .navbar .buttons {
        display: flex;
        gap: 1rem;
        margin-right: auto; /* Move buttons to the left */
      }

      .navbar h1 {
        font-size: 1.5rem;
        margin-left: auto; /* Move title to the right */
      }

      .arrow-up {
        font-size: 1.5rem;
        cursor: pointer;
        margin-right: 1rem;
      }

      /* Page Sections */
      .section {
        padding: 6rem 2rem 2rem;
        min-height: 100vh;
      }

      #information {
        background-color: #f5f5f5;
      }

      #game {
        background-color: #e0e0e0;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
      }

      /* Game Canvas */
      #gameContainer {
        width: 300px; /* Smaller width */
        height: 450px; /* Smaller height */
        position: relative;
        overflow: hidden;
        border: 2px solid #333;
        background-color: #000;
      }
    </style>
  </head>
  <body>
    <!-- Full-screen pop-up -->
    <div id="popup" class="popup">
      <div class="popup-content">
        <h1>Earth Day</h1>
        <p>made by SIS South Jakarta</p>
        <div class="buttons">
          <button id="infoBtn">Information</button>
          <button id="gameBtn">Game</button>
        </div>
        <div id="closePopup" class="arrow-down">&#9660;</div>
      </div>
    </div>

    <!-- Minimized top navigation bar -->
    <nav id="navbar" class="navbar">
      <div id="openPopup" class="arrow-up">&#9650;</div>
      <div class="buttons">
        <button id="infoNavBtn">Information</button>
        <button id="gameNavBtn">Game</button>
      </div>
      <h1>Earth Day</h1>
    </nav>

    <!-- Information Section -->
    <section id="information" class="section">
      <h2>Information</h2>
      <p>Earth Day is an annual event celebrated on April 22. It was first held in 1970 and is now observed globally to demonstrate support for environmental protection. Earth Day serves as a reminder of the importance of preserving our planet and taking action against climate change, pollution, and deforestation.</p>
    </section>

    <!-- Game Section -->
    <section id="game" class="section">
      <h2>Game</h2>
      <div id="gameContainer"></div>
    </section>

    <script>
      // Smooth scrolling function
      function scrollToSection(sectionId) {
        const section = document.getElementById(sectionId);
        section.scrollIntoView({ behavior: 'smooth' });
      }

      // Popup and Navbar functionality
      const popup = document.getElementById('popup');
      const navbar = document.getElementById('navbar');
      const closePopupBtn = document.getElementById('closePopup');
      const openPopupBtn = document.getElementById('openPopup');
      const infoBtn = document.getElementById('infoBtn');
      const gameBtn = document.getElementById('gameBtn');
      const infoNavBtn = document.getElementById('infoNavBtn');
      const gameNavBtn = document.getElementById('gameNavBtn');

      // Close popup and show navbar
      closePopupBtn.addEventListener('click', () => {
        popup.style.transform = 'translateY(-100%)';
        navbar.style.top = '0';
      });

      // Open popup and hide navbar
      openPopupBtn.addEventListener('click', () => {
        popup.style.transform = 'translateY(0)';
        navbar.style.top = '-100px';
      });

      // Scroll to Information section
      infoBtn.addEventListener('click', () => {
        popup.style.transform = 'translateY(-100%)';
        navbar.style.top = '0';
        scrollToSection('information');
      });

      infoNavBtn.addEventListener('click', () => {
        scrollToSection('information');
      });

      // Scroll to Game section
      gameBtn.addEventListener('click', () => {
        popup.style.transform = 'translateY(-100%)';
        navbar.style.top = '0';
        scrollToSection('game');
      });

      gameNavBtn.addEventListener('click', () => {
        scrollToSection('game');
      });

      // Doodle Jump Game in p5.js
      let doodler;
      let platforms = [];
      let gap;
      let score = 0;
      let gameState = "start"; // "start", "playing", "gameover"
      let holeX, holeY; // For the deadly hole
      let holeActive = false;

      // Celestial objects stored in world coordinates.
      let stars = [];   // Target: 15 stars

      // A fixed world floor y-position (world coordinate)
      const worldFloorY = 450; // Adjusted for smaller canvas

      function setup() {
        const gameCanvas = createCanvas(300, 450); // Smaller canvas size
        gameCanvas.parent('gameContainer');
        doodler = new Doodler();

        // Create initial platforms
        let platformCount = 6;
        gap = height / 4;
        for (let i = 0; i < platformCount; i++) {
          platforms.push(new Platform(randomPlatformX(), worldFloorY - i * gap));
        }
      }

      function draw() {
        // Compute sky darkness with a slower transition (from score 0 to 100)
        let darkness = constrain(map(score, 0, 100, 0, 1), 0, 1);
        let skyR = lerp(173, 0, darkness);
        let skyG = lerp(216, 0, darkness);
        let skyB = lerp(230, 64, darkness);
        background(skyR, skyG, skyB);

        if (gameState === "start") {
          startScreen();
        } else if (gameState === "playing") {
          playGame(darkness);
        } else if (gameState === "gameover") {
          gameOverScreen();
        }
      }

      // Helper: Check if a candidate star is too close to existing stars (within 10 pixels)
      function starTooClose(candidate, starArray) {
        for (let s of starArray) {
          if (dist(candidate.x, candidate.y, s.x, s.y) < 10) {
            return true;
          }
        }
        return false;
      }

      // Update stars in world coordinates.
      function updateStars(darkness) {
        let topVisible = doodler.y - height / 2;
        let bottomVisible = doodler.y + height / 2;
        let margin = 50;

        // Spawn stars only when the sky is fully dark (darkness >= 1).
        if (darkness >= 1) {
          // Remove stars off-screen.
          for (let i = stars.length - 1; i >= 0; i--) {
            if (stars[i].y > bottomVisible + margin || stars[i].y < topVisible - margin) {
              stars.splice(i, 1);
            }
          }
          // Spawn new stars until we have 15.
          while (stars.length < 15) {
            let candidate = {
              x: random(width),
              y: topVisible - random(50, 100),
              size: random(1, 3)
            };
            // Ensure candidate is not within the tree region.
            if (candidate.x > width / 2 - 100 && candidate.x < width / 2 + 100) continue;
            // Ensure candidate is not within 10 pixels of another star.
            if (starTooClose(candidate, stars)) continue;
            stars.push(candidate);
          }
        } else {
          stars = [];
        }
      }

      // Draw the stars.
      function drawStars() {
        noStroke();
        fill(255);
        for (let star of stars) {
          ellipse(star.x, star.y, star.size, star.size);
        }
      }

      // Draw a fixed tree trunk in fixed screen coordinates so it always appears.
      function drawTreeFixed() {
        fill(139, 69, 19);
        noStroke();
        rect(width / 2 - 100, 0, 200, height);
      }

      // Main game-playing function.
      function playGame(darkness) {
        // Draw fixed elements (like the tree) in screen coordinates.
        drawTreeFixed();

        // Switch to world coordinates.
        push();
        translate(0, height / 2 - doodler.y);

        // Update and draw stars.
        updateStars(darkness);
        drawStars();

        // Draw moving floor.
        fill(210, 180, 140);
        noStroke();
        rect(0, worldFloorY, width, 20);

        // --------- Hole (Danger) Handling ---------
        if (frameCount % 200 === 0 && random() < 0.2) {
          let candidateX = width / 2 - 100 + random(200);
          let candidateY = doodler.y - height / 2 - 100;
          if (canSpawnHoleAt(candidateX, candidateY)) {
            holeX = candidateX;
            holeY = candidateY;
            holeActive = true;
          }
        }
        if (holeActive && holeY < doodler.y - height / 2 - 150) {
          holeActive = false;
        }
        if (holeActive) {
          drawPixelatedHole(holeX, holeY);
        }

        // Draw and update doodler and platforms.
        doodler.draw();
        doodler.update(platforms);
        for (let platform of platforms) {
          platform.draw();
        }
        if (platforms.length > 0 && doodler.y < platforms[platforms.length - 1].y + 200) {
          platforms.push(new Platform(randomPlatformX(), platforms[platforms.length - 1].y - gap));
        }
        if (platforms.length > 0 && platforms[0].y > doodler.y + 400) {
          platforms.splice(0, 1);
          score++;
        }

        pop();

        // Draw score in fixed coordinates.
        push();
        fill(255);
        textSize(20);
        textAlign(CENTER);
        text(score, width / 2, 30);
        pop();

        if (doodler.y > worldFloorY + doodler.height || (holeActive && doodlerHitsHole())) {
          gameState = "gameover";
        }
      }

      // Draw a pixelated dark brown hole.
      function drawPixelatedHole(x, y) {
        fill(101, 67, 33);
        noStroke();
        let size = 40;
        let pixelSize = 8;
        for (let i = 0; i < size; i += pixelSize) {
          for (let j = 0; j < size; j += pixelSize) {
            if (random() < 0.7) {
              rect(x + i - size / 2, y + j - size / 2, pixelSize, pixelSize);
            }
          }
        }
      }

      // Prevent holes from spawning on top of a platform.
      function canSpawnHoleAt(x, y) {
        let holeSize = 40;
        for (let p of platforms) {
          if (
            x + holeSize / 2 > p.x &&
            x - holeSize / 2 < p.x + p.width &&
            y + holeSize / 2 > p.y &&
            y - holeSize / 2 < p.y + p.height
          ) {
            return false;
          }
        }
        return true;
      }

      function startScreen() {
        fill(255);
        textSize(20);
        textAlign(CENTER, CENTER);
        text("Tree Climber", width / 2, height / 2 - 50);
        textSize(16);
        text("Press SPACE to Start", width / 2, height / 2);
      }

      function gameOverScreen() {
        fill(255);
        textSize(20);
        textAlign(CENTER, CENTER);
        text("Game Over", width / 2, height / 2 - 50);
        textSize(16);
        text("Score: " + score, width / 2, height / 2);
        text("Press SPACE to Restart", width / 2, height / 2 + 50);
      }

      function keyPressed() {
        if (gameState === "start" && key === ' ') {
          gameState = "playing";
        } else if (gameState === "gameover" && key === ' ') {
          resetGame();
        }
      }

      function resetGame() {
        doodler = new Doodler();
        platforms = [];
        score = 0;
        holeActive = false;
        stars = [];
        
        let platformCount = 6;
        gap = height / 4;
        for (let i = 0; i < platformCount; i++) {
          platforms.push(new Platform(randomPlatformX(), worldFloorY - i * gap));
        }
        gameState = "playing";
      }

      function randomPlatformX() {
        let minX = width / 2 - 100 - 60 * 0.8;
        let maxX = width / 2 + 100 - 60 * 0.2;
        return random(minX, maxX);
      }

      // Doodler Class
      class Doodler {
        constructor() {
          this.x = width / 2;
          this.y = worldFloorY - 200;
          this.width = 40;
          this.height = 40;
          this.velocity = 0;
          this.gravity = 0.1;
          this.jumpForce = 9;
        }
        draw() {
          noStroke();
          fill(255, 0, 0);
          rect(this.x, this.y, this.width, this.height);
        }
        update(platforms) {
          if (this.x + this.width < 0) this.x = width;
          if (this.x > width) this.x = -this.width;
          this.velocity += this.gravity;
          this.y += this.velocity;
          // Increase horizontal speed (faster movement)
          if (keyIsDown(LEFT_ARROW)) {
            this.x -= 6;
          }
          if (keyIsDown(RIGHT_ARROW)) {
            this.x += 6;
          }
          for (let platform of platforms) {
            if (
              this.y + this.height >= platform.y &&
              this.y + this.height <= platform.y + platform.height
            ) {
              let minX = platform.x - this.width;
              let maxX = platform.x + platform.width;
              if (this.x >= minX && this.x <= maxX) {
                this.velocity = this.velocity > 0 ? -this.jumpForce * 0.8 : -this.jumpForce;
              }
            }
          }
          if (this.velocity < -9) this.velocity = -9;
        }
        jump() {
          this.velocity -= this.jumpForce;
        }
      }

      // Platform Class
      class Platform {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.width = 60;
          this.height = 15;
        }
        draw() {
          noStroke();
          fill(34, 139, 34);
          rect(this.x, this.y, this.width, this.height);
        }
      }

      function doodlerHitsHole() {
        let holeSize = 40;
        return (
          doodler.x + doodler.width > holeX - holeSize / 2 &&
          doodler.x < holeX + holeSize / 2 &&
          doodler.y + doodler.height > holeY - holeSize / 2 &&
          doodler.y < holeY + holeSize / 2
        );
      }
    </script>
  </body>
  </html>
