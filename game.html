
  <!DOCTYPE html>
    <script>
      // Smooth scrolling function
      function scrollToSection(sectionId) {
        const section = document.getElementById(sectionId);
        section.scrollIntoView({ behavior: 'smooth' });
      }

      // Popup and Navbar functionality
      const popup = document.getElementById('popup');
      const navbar = document.getElementById('navbar');
      const closePopupBtn = document.getElementById('closePopup');
      const openPopupBtn = document.getElementById('openPopup');
      const infoBtn = document.getElementById('infoBtn');
      const gameBtn = document.getElementById('gameBtn');
      const infoNavBtn = document.getElementById('infoNavBtn');
      const gameNavBtn = document.getElementById('gameNavBtn');

      // Close popup and show navbar
      closePopupBtn.addEventListener('click', () => {
        popup.style.transform = 'translateY(-100%)';
        navbar.style.top = '0';
      });

      // Open popup and hide navbar
      openPopupBtn.addEventListener('click', () => {
        popup.style.transform = 'translateY(0)';
        navbar.style.top = '-100px';
      });

      // Scroll to Information section
      infoBtn.addEventListener('click', () => {
        popup.style.transform = 'translateY(-100%)';
        navbar.style.top = '0';
        scrollToSection('information');
      });

      infoNavBtn.addEventListener('click', () => {
        scrollToSection('information');
      });

      // Scroll to Game section
      gameBtn.addEventListener('click', () => {
        popup.style.transform = 'translateY(-100%)';
        navbar.style.top = '0';
        scrollToSection('game');
      });

      gameNavBtn.addEventListener('click', () => {
        scrollToSection('game');
      });

      // Doodle Jump Game in p5.js
      let doodler;
      let platforms = [];
      let gap;
      let score = 0;
      let gameState = "start"; // "start", "playing", "gameover"
      let holeX, holeY; // For the deadly hole
      let holeActive = false;

      // Celestial objects stored in world coordinates.
      let stars = [];   // Target: 15 stars

      // A fixed world floor y-position (world coordinate)
      const worldFloorY = 450; // Adjusted for smaller canvas

      function setup() {
        const gameCanvas = createCanvas(300, 450); // Smaller canvas size
        gameCanvas.parent('gameContainer');
        doodler = new Doodler();

        // Create initial platforms
        let platformCount = 6;
        gap = height / 4;
        for (let i = 0; i < platformCount; i++) {
          platforms.push(new Platform(randomPlatformX(), worldFloorY - i * gap));
        }
      }

      function draw() {
        // Compute sky darkness with a slower transition (from score 0 to 100)
        let darkness = constrain(map(score, 0, 100, 0, 1), 0, 1);
        let skyR = lerp(173, 0, darkness);
        let skyG = lerp(216, 0, darkness);
        let skyB = lerp(230, 64, darkness);
        background(skyR, skyG, skyB);

        if (gameState === "start") {
          startScreen();
        } else if (gameState === "playing") {
          playGame(darkness);
        } else if (gameState === "gameover") {
          gameOverScreen();
        }
      }

      // Helper: Check if a candidate star is too close to existing stars (within 10 pixels)
      function starTooClose(candidate, starArray) {
        for (let s of starArray) {
          if (dist(candidate.x, candidate.y, s.x, s.y) < 10) {
            return true;
          }
        }
        return false;
      }

      // Update stars in world coordinates.
      function updateStars(darkness) {
        let topVisible = doodler.y - height / 2;
        let bottomVisible = doodler.y + height / 2;
        let margin = 50;

        // Spawn stars only when the sky is fully dark (darkness >= 1).
        if (darkness >= 1) {
          // Remove stars off-screen.
          for (let i = stars.length - 1; i >= 0; i--) {
            if (stars[i].y > bottomVisible + margin || stars[i].y < topVisible - margin) {
              stars.splice(i, 1);
            }
          }
          // Spawn new stars until we have 15.
          while (stars.length < 15) {
            let candidate = {
              x: random(width),
              y: topVisible - random(50, 100),
              size: random(1, 3)
            };
            // Ensure candidate is not within the tree region.
            if (candidate.x > width / 2 - 100 && candidate.x < width / 2 + 100) continue;
            // Ensure candidate is not within 10 pixels of another star.
            if (starTooClose(candidate, stars)) continue;
            stars.push(candidate);
          }
        } else {
          stars = [];
        }
      }

      // Draw the stars.
      function drawStars() {
        noStroke();
        fill(255);
        for (let star of stars) {
          ellipse(star.x, star.y, star.size, star.size);
        }
      }

      // Draw a fixed tree trunk in fixed screen coordinates so it always appears.
      function drawTreeFixed() {
        fill(139, 69, 19);
        noStroke();
        rect(width / 2 - 100, 0, 200, height);
      }

      // Main game-playing function.
      function playGame(darkness) {
        // Draw fixed elements (like the tree) in screen coordinates.
        drawTreeFixed();

        // Switch to world coordinates.
        push();
        translate(0, height / 2 - doodler.y);

        // Update and draw stars.
        updateStars(darkness);
        drawStars();

        // Draw moving floor.
        fill(210, 180, 140);
        noStroke();
        rect(0, worldFloorY, width, 20);

        // --------- Hole (Danger) Handling ---------
        if (frameCount % 200 === 0 && random() < 0.2) {
          let candidateX = width / 2 - 100 + random(200);
          let candidateY = doodler.y - height / 2 - 100;
          if (canSpawnHoleAt(candidateX, candidateY)) {
            holeX = candidateX;
            holeY = candidateY;
            holeActive = true;
          }
        }
        if (holeActive && holeY < doodler.y - height / 2 - 150) {
          holeActive = false;
        }
        if (holeActive) {
          drawPixelatedHole(holeX, holeY);
        }

        // Draw and update doodler and platforms.
        doodler.draw();
        doodler.update(platforms);
        for (let platform of platforms) {
          platform.draw();
        }
        if (platforms.length > 0 && doodler.y < platforms[platforms.length - 1].y + 200) {
          platforms.push(new Platform(randomPlatformX(), platforms[platforms.length - 1].y - gap));
        }
        if (platforms.length > 0 && platforms[0].y > doodler.y + 400) {
          platforms.splice(0, 1);
          score++;
        }

        pop();

        // Draw score in fixed coordinates.
        push();
        fill(255);
        textSize(20);
        textAlign(CENTER);
        text(score, width / 2, 30);
        pop();

        if (doodler.y > worldFloorY + doodler.height || (holeActive && doodlerHitsHole())) {
          gameState = "gameover";
        }
      }

      // Draw a pixelated dark brown hole.
      function drawPixelatedHole(x, y) {
        fill(101, 67, 33);
        noStroke();
        let size = 40;
        let pixelSize = 8;
        for (let i = 0; i < size; i += pixelSize) {
          for (let j = 0; j < size; j += pixelSize) {
            if (random() < 0.7) {
              rect(x + i - size / 2, y + j - size / 2, pixelSize, pixelSize);
            }
          }
        }
      }

      // Prevent holes from spawning on top of a platform.
      function canSpawnHoleAt(x, y) {
        let holeSize = 40;
        for (let p of platforms) {
          if (
            x + holeSize / 2 > p.x &&
            x - holeSize / 2 < p.x + p.width &&
            y + holeSize / 2 > p.y &&
            y - holeSize / 2 < p.y + p.height
          ) {
            return false;
          }
        }
        return true;
      }

      function startScreen() {
        fill(255);
        textSize(20);
        textAlign(CENTER, CENTER);
        text("Tree Climber", width / 2, height / 2 - 50);
        textSize(16);
        text("Press SPACE to Start", width / 2, height / 2);
      }

      function gameOverScreen() {
        fill(255);
        textSize(20);
        textAlign(CENTER, CENTER);
        text("Game Over", width / 2, height / 2 - 50);
        textSize(16);
        text("Score: " + score, width / 2, height / 2);
        text("Press SPACE to Restart", width / 2, height / 2 + 50);
      }

      function keyPressed() {
        if (gameState === "start" && key === ' ') {
          gameState = "playing";
        } else if (gameState === "gameover" && key === ' ') {
          resetGame();
        }
      }

      function resetGame() {
        doodler = new Doodler();
        platforms = [];
        score = 0;
        holeActive = false;
        stars = [];
        
        let platformCount = 6;
        gap = height / 4;
        for (let i = 0; i < platformCount; i++) {
          platforms.push(new Platform(randomPlatformX(), worldFloorY - i * gap));
        }
        gameState = "playing";
      }

      function randomPlatformX() {
        let minX = width / 2 - 100 - 60 * 0.8;
        let maxX = width / 2 + 100 - 60 * 0.2;
        return random(minX, maxX);
      }

      // Doodler Class
      class Doodler {
        constructor() {
          this.x = width / 2;
          this.y = worldFloorY - 200;
          this.width = 40;
          this.height = 40;
          this.velocity = 0;
          this.gravity = 0.1;
          this.jumpForce = 9;
        }
        draw() {
          noStroke();
          fill(255, 0, 0);
          rect(this.x, this.y, this.width, this.height);
        }
        update(platforms) {
          if (this.x + this.width < 0) this.x = width;
          if (this.x > width) this.x = -this.width;
          this.velocity += this.gravity;
          this.y += this.velocity;
          // Increase horizontal speed (faster movement)
          if (keyIsDown(LEFT_ARROW)) {
            this.x -= 6;
          }
          if (keyIsDown(RIGHT_ARROW)) {
            this.x += 6;
          }
          for (let platform of platforms) {
            if (
              this.y + this.height >= platform.y &&
              this.y + this.height <= platform.y + platform.height
            ) {
              let minX = platform.x - this.width;
              let maxX = platform.x + platform.width;
              if (this.x >= minX && this.x <= maxX) {
                this.velocity = this.velocity > 0 ? -this.jumpForce * 0.8 : -this.jumpForce;
              }
            }
          }
          if (this.velocity < -9) this.velocity = -9;
        }
        jump() {
          this.velocity -= this.jumpForce;
        }
      }

      // Platform Class
      class Platform {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.width = 60;
          this.height = 15;
        }
        draw() {
          noStroke();
          fill(34, 139, 34);
          rect(this.x, this.y, this.width, this.height);
        }
      }

      function doodlerHitsHole() {
        let holeSize = 40;
        return (
          doodler.x + doodler.width > holeX - holeSize / 2 &&
          doodler.x < holeX + holeSize / 2 &&
          doodler.y + doodler.height > holeY - holeSize / 2 &&
          doodler.y < holeY + holeSize / 2
        );
      }
    </script>
  </body>
  </html>
